## 问题回答
-----------

注：提交内容与完成情况等写在了README里

### Bison的输入文法规范文件的格式
Bison输入文件的格式与flex有很多相似的地方，都分为三个部分，以%%隔开。三个部分分别是声明，语法规则，和用户自己的代码。

声明部分一般会插入一些C的代码，用于声明外部变量，包含头文件等，这些代码被以%{ %}包住，会原封不动地复制到产生的文件中。声明部分还会声明各种会用到的token，他们的类型，优先级等。

语法规则部分包含我们想要描述的语法规则，以及他们的语义动作，语法规则用类似 exp：exp ‘+’ exp | exp ‘-’ exp这样的格式表示，语义动作用{}包住的C语言语句表示，紧跟在对应的语法规则后面。语义值用$$,$1,$2来引用。

用户自己的代码部分可以用来实现yyerror等函数。

### Bison如何与Flex协作生成分析器
bison在分析过程中需要调用yylex来从输入流中读取token，它不会自动实现这个函数，而是需要用户实现，flex可以提供yylex这个函数。而另一方面，bison可以将在声明部分定义的token自动进行定义，并且写入到头文件中（需加上--defines=filename.h的编译选项），供flex使用。bison和flex的协作主要就是这样完成的，如果需要另外的数据交流，可以通过定义全局变量来实现。

### 所生成的分析器的接口形式和实现具有什么特点
所实现分析器的接口中最重要的是yyparse函数，调用它，分析器就会开始工作，读取token，执行在文法规范文件中定义的动作，直到到达EOF或者遇到无法恢复的语法错误。如果分析成功，就返回0，如果因为语法错误失败返回1，因为内存耗尽失败返回2。parse所接收的参数可以使用%parse-param进行定义，从而将文件名等有用的信息传给分析器。

此外还有单独分析下一个token的yypush_parse函数和分析输出流余下的部分的yypulll_parse函数。以及产生一个新的分析器实例的yypstate_new函数和相应的删除函数yypstate_delete。

另外，要使分析器能够工作，还需要用户自己提供yylex函数用于词法分析。

### 语言的文法对生成的分析器的分析表的状态空间有何影响
一般更复杂的文法产生的状态空间就更大。例如，助教给的示例中文法产生的状态只有27个，而C1语言文法对应分析器的分析表的状态有118个。


### 1.查看bison-examples中Makefile文件里名为expr的编译任务，解释任务中各个命令的作用和所使用的选项的含义。

    $(YACC) -b $@ -o $(SRC)/$@.tab.c $(CONF)/$@.y
这条命令将.y文件编译为包含分析器实现的C语言文件。-b选项设定了输出文件的前缀，-o设定输出文件，-y都是为了模拟yacc，-d是为了输出头文件。
    
    $(LEX) -o $(SRC)/$@.lex.c $(CONF)/expr.lex
这条命令将.lex文件编译为包含lexer实现的C语言文件，-o设定了输出文件， -i选项忽视模式中的大小写， -I产生交互式的lexer

    $(CC) -o $(BIN)/$@ $(SRC)/$@.lex.c $(SRC)/$@.tab.c -ll -lm
这条命令将前两条生成的C语言源文件编译为可执行程序。-o指定输出文件，-ll和-lm分别是连接到lex库和math库

 
### 2.通过expr.y和expr1.y描述Yacc输入文法规范文件的格式，消化语法制导的翻译方案。
Yacc输入文法规范文件都分为三个部分，以%%隔开。三个部分分别是声明，语法规则，和用户自己的代码。

声明部分一般会插入一些C的代码，用于声明外部变量，包含头文件等，这些代码被以%{ %}包住，会原封不动地复制到产生的文件中，expr.y和expr1.y都用这种方式包含了标准输入库和数学库的头文件。声明部分还会声明各种会用到的token，他们的类型，优先级等，expr.y和expr1.y在这里声明各种运算符号以及number的语义值类型。

语法规则部分包含我们想要描述的语法规则，以及他们的语义动作，语法规则用类似 exp：exp ‘+’ exp | exp ‘-’ exp这样的格式表示，语义动作用{}包住的C语言语句表示，紧跟在对应的语法规则后面。语义值用$$,$1,$2来引用。expr.y和expr1.y中都有类似与$$ = $1 + $2这样的语义动作，通过这样的语义动作来完成语法制导的翻译方案。

用户自己的代码部分可以用来实现yyerror等函数。expr.y和expr1.y都在这里实现了main函数和yyerror函数。


### 3.阅读并对比bison-examples中src目录下的expr.tab.h、expr.tab.c和expr1.tab.c，总结expr.tab.c和expr1.tab.c的异同。说明expr.y和expr1.y中对表达式语言的不同文法表示对生成的分析器源代码expr.tab.c和expr1.tab.c有何影响。

expr.tab.c和expr1.tab.c的不同之处有：

    （1）、enum yytokentype不同，因为定义的token不同。
    
    （2）、yytranslate，yypact，yytable等等几张表不同，这些表是用于状态之间的转换和在某个状态采取相应动作的表（yytable），以及将定义的token类型转化为数组的下表（yytranslate，yypact）等起辅助作用的表。
    
    （3）、yyparse函数中执行的语义动作不同。
    
文法规范文件中文法的不同会影响到yyparse中的语义动作（主要是函数里那个switch），也会影响到状态表和一些辅助用表（yytable，yytranslate等数组都会发生变化）


### 4.阅读、理解bison-examples中config目录下的asgn.y和asgn1.y、src目录下的asgn.lex.c, asgn.tab.h, asgn.tab.c, asgn1.tab.c，了解L-asgn分析器的构成方法，简述.tab.c和.lex.c文件的结构。

.tab.c的结构：

首先是用户引入的一系列声明和定义，如一些外部变量的声明，和对标准库的头文件的包含等。

然后是一系列的数组定义，yytranslate用于将token的类型转化为可用的数组下标，yyrline储存语法规则所在的行数。。。。其中比较重要的有yypact，yydefact，yytable，这几个数组起到了分析表的作用，yytable很接近我们学的分析表，只不过它是一维的，需要进行一些下标变换来找到正确的表项，而yypact，yydefact就是进行这些下标变换的。

然后是一系列函数，首先是一些用于打印symbol和stack等等的辅助函数，以及用于strcpy和strlen的辅助函数。之后是处理语法错误的yysyntax_error函数。之后就到了重头戏，yyparse函数。yyparse函数维护了两个栈：状态栈yyss和语义值栈yyvs，yyparse会不断读取token，通过之前的一些表进行下标计算，然后通过yytable进行状态转换，并执行shift和reduce。yyparse中同样有很多的共同语句，可能是处于效率的考虑。

最后就是一些用户定义的函数，如yyerror，main函数等。


.lex.c的结构：
因为感觉.lex.c的可读性比.tab.c差很多，所以这部分答得比较简略。

首先是用户引入的一系列声明和定义，如一些外部变量的声明，和对标准库的头文件的包含等。  

然后也是一些辅助用的结构体的定义，一些数组的定义。

之后是scanner主体函数YY_DECL，函数中同样包含了大量goto语句，其中一个swich语句决定了执行哪一个词法分析的动作。

之后是一些用于内存分配的辅助函数。

最后就是一些用户定义的函数，如yywrab，main函数等。











