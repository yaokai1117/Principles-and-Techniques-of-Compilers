## 设计文档
---------

注：提交内容与完成情况等写在了README里

### 1.编写C1的文法规范文件并且打印产生式

这一步骤没有遇到太多困难。编写C1的文法规范主要还是按照附录中的C1文法转成bison的格式，当出现一个表达式可以重复多次的情况（如VarDecl -> int Var {，Var} ';')，我采用的方法是增加一个VarList产生式表示一个或多个Var，写成递归的形式（类似于VarList -> Var | VarList Var)。

另一个问题就是if-else的SR冲突问题，和接下来错误恢复中遇到的一些问题一样，这个可以通过设置产生式的优先级来消除冲突。这里我设置了一个NO_ELSE的precedence，并且将其优先级设得比ELSE低，然后将它加给无else的if语句产生式，这样分析器在遇到else时就会优先移进（当然默认也是优先移进），同时不会再报conflict。

打印产生式使用了助教提供的宏，美观方便。


### 2.错误检测和恢复

这一部分要困难一些，因为会遇到一些冲突，这些冲突通过设优先级等方法可以全部消去。下面对这些冲突和消去他们的办法进行了具体的说明。

（1）、对于缺少int的warning，直接加一个对应的产生式即可。

（2）、对于缺少括号的的错误则更难处理一些，对于缺少左括号和缺少右括号采取了不同的方法。
为了方便说明，给相关的三个产生式编号如下

       （1） Exp -> LPARENT Exp RPARENT     //正确的
       （2） Exp -> Exp ERR_RPARENT       //缺少左括号
       （3） Exp -> LPARENT Exp %prec MISSING_RPARENT     //缺少右括号

首先我在lexer的部分加入了一个全局变量lparent_num，每当lexer产生一个LPARENT的token，就将lparent_num加一，产生一个RPARENT的token，就将其减一。这样，当遇到右括号时，lparent_num应该大于0，否则就出现了缺少左括号的情况，这时lexer不返回RPARENT，而返回一个ERR_RPARENT。然后在parser中加入一条新的产生式Exp -> Exp ERR_RPARENT,这样就可以正确的识别缺少左括号的表达式，并且从错误中恢复。

这样做的原因是避免归约归约冲突，因为如果返回普通的RPARENT，这时产生式2中的ERR_RPARENT就变成了RPARENT，分析器在面临Exp LPARENT时，会不知道按产生式1归约还是按产生式2归约。

缺少右括号的处理相对容易一些，只要加入一条新的对应的产生式Exp -> LPARENT Exp即可。因为不会有归约归约冲突，只有移进归约冲突（在面临LPARENT Exp时，按产生式1移进，还是按产生式2归约）。处理移进归约冲突的方法与之前if-else一样，给识别错误语句的产生式加优先级MISSING_RPARENT，使它的优先级低于RPARENT的优先级即可。（当然默认优先移进的结果也是对的，加了优先级可以让它不报warning）

（3）、缺少运算符的错误。这里首先要说一下这个错误的恢复方式，我设想的恢复方式是，先把所缺少的符号两边的表达式都计算完，然后只保留后一个表达式的值作为整个表达式的值，即把所缺少的运算符看成C语言中的逗号运算符。

我使用的方法是加入一个产生式Exp -> Exp error Exp。困难的地方在于，这个产生式会带来许多移进归约冲突，且不像之前那样易于解决。因为冲突都是类似于Exp PLUS Exp在面临error时应该先移进还是进行归约，默认的做法是移进，至于这样是否正确取决于你想把这个缺少的运算符当成什么，如果当成乘号，默认先移进是正确的，如果当成优先级低于加号的符号（例如C语言中的逗号），默认处理是不正确的，因为这时应该先归约。由于我希望将所缺的运算符相当与C中的逗号，优先级最低，所以默认处理对我来说是不正确的。

最终我的解决办法是，用 %left error 把error设成优先级最低，且结合性为左结合（这样设还是因为我的将缺少的运算符看成逗号的思路），这样，由于增加这个处理错误的产生式相当于增加了一个新的运算符号，且这个运算符号的结合性和优先级都已经确定，所以移进归约冲突得到了解决。

由于这里捕获错误的产生式中用到了error，所以固定会打印一个syntax error，请无视它。

（4）、缺少分号的错误。这个错误看似简单，实际上也会遇到移进归约冲突的问题，例如，产生式
    
    VarDecl -> int VarList ';'          //正确产生式
    VarDecl -> int VarList              //对应的缺少分号的错误产生式
    
在面临int VarList时可以移进，也可以按捕获错误的产生式归约。解决的办法还是设优先级，即给第二个产生式设优先级MISSING_SEMICOLON，而MISSING_SEMICOLON的优先级低于正常的分号。

### 错误信息的处理

在这个部分中，尝试使用了工厂模式，实现了一个MsgFactory类，负责产生，维护，显示错误信息和警告信息。

为了实现和Clang类似的错误信息显示。MsgFactory中维护了一个数组，记录源文件中每一行开头的位置信息，这样在输出错误信息时就可以通过行号和这个数组完成错误行的输出。

为了处理tab的问题，MsgFactory在输出一行会先将tab全部转化为4个空格在进行输出。


