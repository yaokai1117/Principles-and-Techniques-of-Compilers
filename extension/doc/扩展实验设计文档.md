## 扩展实验设计文档
---------------------------

扩展实验在P7的基础上给C1编译器加了一些特性：在代码生成前增加了一趟类型检查，可以识别一些复杂的类型，并且报一些类型上的错误；支持了浮点数和字符类型；支持了结构体类型和指针类型。

下面分别说明其设计思路：


### 增加一趟类型检查

在拓展实验中，我将对AST的操作全部改为了Visitor模式，生产DOT、类型检查、代码生成分别为三个独立的Visitor，可以由AST分别accept来完成相应的遍历操作。这样想要增加或变更一趟对语法树的扫描都容易一些，且不用改变AST的定义。

类型检查是加在代码生产之前的一趟扫描，主要功能有AST节点类型的确定，类型检查和提升，简单的常量传播。

首先修改语法分析部分的规则来识别类型更加复杂的变量定义，如确定：
    
    int *a[100];    为整数指针的数组    array（pointer（int), 100)
    而int (*a)[100]; 为指向整型数组的指针   pointer(array(int, 100))
    int (*a)(int b, int b)[10]; 为指向一个返回长度为10的整形数组的函数的指针（当然函数返回值为数组这一点我还没能在代码生成中支持）  pointer((int, int)->array(int, 10))
  
    
AST节点类型的确定是在扫描AST的过程中自底向上地确定每一个节点的类型（如果它有类型的话），例如一个BinaryExpNode，如果它的lhs为int类型，rhs也为int，那么它本身的节点类型就是int。节点的类型保存在每个Node的valueTy域中（这里还是改动了ASTNode的定义，似乎违背了使用Visitor模式的初衷，但这样做确实会比较简单，而且AST节点中保存type信息是挺有必要的，代码生成中也会多次用到）。对于数组和指针这样的节点，通过在ValueType结构体中增加一个atom指针指向他的atom类型，即可递归地进行处理，这一点在处理复杂类型的变量的定义的时候会很有用。

类型检查和提升是基于在上一步中确定的节点类型的。主要检查二元和一元运算的运算符类型，如int加上float需要将int提升为float，将一个float赋给int需要进行类型转换，而如果取模运算的操作数是浮点则要报错。具体的实现主要是在ValueType结构体中加一个dstType域，若为NO_TYPE则不需要进行类型转换，若为其他则需要在代码生成时生成相应的转化代码。此外，还有关于const和重复定义等问题的报错。

常量传播是通过在ValueType中加一个constVal域和一个isComputed标志来完成的，在类型检查这一步计算出能计算的常量。


### 支持浮点数和字符，以及多维数组和带参数和返回值的函数

在代码生成部分对照整形进行相应内容的改动和添加，由于之前类型检查已经确定了每一个节点的类型，这里的代码生成方便了一些。


### 支持结构体和指针

这一部分是最为困难和耗时的，且最终在代码生成中仍有一些地方来不及完善（主要是数组到指针的转换没有完成和它们作为函数参数时存在一些问题没有解决）。首先在语法规则部分进行了很多改动来支持结构体和指针，引用和解引用被当作单目运算符来处理，由struct关键字来指明结构体类型。然后在类型检查中确定每个节点的类型，对于‘&’和‘*‘运算符进行会在ValueType上进行相应的引用和脱引用操作。

然后是代码生成，结构体和指针在llvm中都有对应的Type和Value类型，借助之前P7中使用的“反汇编”的方法可以了解到相应api的使用。对于结构体的实现，首先要在Module里面定义结构体的类型，llvm对于结构体属性的寻址是通过一个结构体指针和一个offset来确定的，因此需要给每个结构体保存一个map来完成属性名字到offset的映射。指针的实现主要是将变量的地址（一般是一个AllocaInst指针）作为指针变量的值进行存储，对于指向函数、数组元素、结构体属性、还有类似 &(*pa)这样的指针要特别进行处理，而如果引用操作符（&）的操作数不是一个左值，则视为类型错误。

比较困难的地方有这几个：首先是函数指针，需要在类型检查中改一些地方，因为例如 

int (*padd)(int a, int b) = add;

其中add是已经定义好的函数，则此时padd和*padd起的作用是一样的，而他们类型不同，需要在类型检查中“放他一马”。最终实现了这个功能并且能作为函数参数传递。

另一个是结构体作为函数参数，这里我只实现了结构体指针作为函数参数，可以正常运行，但如果结构体直接作为参数则不行（这里主要是我实现上的问题，最后来不及进行比较大的改动了）。与之类似的是只支持结构体指针的数组而不能直接是结构体数组。




    
    
    
    
    
    
    
    
    
    
    
    
    