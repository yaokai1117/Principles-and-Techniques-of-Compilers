## P7
-------------------

### 1、解释Module、IRBuilder<>的作用，说明：Kaleidoscope的符号表使用了什么结构，有什么限制

Module是包含所有全局变量和函数的结构。其中包含了一个函数符号表，在生成函数体的代码时会将函数注册进Module，在调用函数时会根据函数名从Module中获取对应的函数。

Builder是一个用于生成llvm中间码的对象，它记录了当前插入指令的位置，并包含了一系列产生llvm指令的函数。

**在第三章中**Kaleidoscope的符号表使用一个从string到Value指针的map结构，限制在于符号表中变量的值是不可变的，这是因为这时还没有引入局部变量，所以符号表中只会有函数的参数。
**在第七章中**Kaleidoscope的符号表的结构为一个从string到AllocaInst指针的map结构，AllocaInst可以理解为变量存储的内存位置，这里我们已经引入了局部变量，符号表中的变量现在是可变的了。


### 2、为何使用常量是用的函数名是get而不是create

这是因为在LLVM IR中常量的表示是唯一的且是共享的，即同一个常量只存在一个实例，所以使用常量的函数名用get而不是create，因为并不会重新创建一个常量，而只是获取那个唯一的实例（当然推测第一次get时还是会进行创建的）。


### 3、简要说明声明和定义一个函数的过程

在产生一个函数的声明的代码时（对应PrototypeAST的Codegen），首先要产生一个它的参数类型列表，然后以函数的返回值类型和参数类型列表来产生函数的类型（FunctionType对象）。接着由函数名和FunctionType在Module中创建一个Function对象，然后判断是否Module中已经存在同名的函数，如果已经有这个名字的函数并且是已经定义过，或是只声明过但参数类型不同的，就报相应的错误。
在产生一个函数的定义的代码时（对应FunctionAST的Codegen），因为一般定义是和声明结合在一块的，所以会首先按照上述的方法产生其对应的声明的代码（即首先调用Proto的Codegen）。然后产生函数体的代码，首先创建一个entry代码块作为函数的入口，然后递归调用Body的代码生产函数产生函数体的代码，最后使用llvm的verifyFunction对函数进行一系列的检验。


### 4、 为什么需要ThenBB = Builder.GetInsertBlock()。

因为if-else作为一个表达式的值是通过一个Phi结点来确定的，Phi结点中有若干个Block/Value对，它根据执行到MergeBB时的前驱基本块是哪个Block（或者说是由哪个Block进入MergeBB）来将对应的Value作为整个if-else语句的返回值。所以在创建Phi结点时需要用到Then语句和Else语句结束时的当前Block，而Then或else自己的代码生成中很可能改变当前的Block（例如嵌套的if语句），所以在它们各自的代码生产结束后必须将ThenBB（和ElseBB）更新为当前的Block，然后再通过PHINode的addIncoming方法添加给Phi结点。

### 5、思考如何修改可以先检查循环条件，如果为真再执行循环体    

可以按如下的逻辑来进行类似while循环的代码生成

    entry：
        goto cond
        
    cond：
        a = cond_expr.codegen()
        i = cmp(a,0)
        if (i == 0) 
            goto body 
        else
            goto end
            
    body :
        body_expr.codegen()
        goto cond
        
    end :
        return 0.0

### 6、说明在有多层嵌套时，7.7节的Local Variables是如何操作符号表的。

在有多层嵌套时，为了防止内层局部变量覆盖外层同名局部变量，会首先从符号表中取出这个名字对应的Alloca（即NamedValue[VarName]）,保存在OldVal中。在内层嵌套结束后，如果OldVal非空，则进行还原（即把符号表中该名字对应的Alloca重新置为OldVal）。









