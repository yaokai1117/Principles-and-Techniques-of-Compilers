l## 阅读Clang语法分析文件
---------------------

### 1、阅读tools/clang/lib/Parse/ParseStmt.cpp 

（1）、阅读ParseIfStatement函数。

ParseIfStatement函数的工作流程：首先读进'if'和一个左括号，然后创建新的作用域IfScope，接着调用ParseParenExprOrCondition读进条件判断表达式。然后为'then'语句块创建一个局部作用域InnerScope（接下来的'else'语句块作用域也叫这个名字，但不是同一个作用域），调用ParseStatement读进并分析'then'语句块。接下来判断下一个token是否为'else'，如果是，则用与解析'then'语句块相同的方法解析'else'语句块（同样要创建一个名为InnerScope的局部作用域）。

3个错误处理手段: 

* 处理开头if后面没有左括号的错误，报缺少左括号的error，并跳过直到下一个分号的一系列token以进行错误恢复，返回StmtError()
* 处理if语句之后（没有else）直接是代码结束，会中断分析，并返回StmtError()
* 处理'then'语句块和'else'语句块出错的问题，如果两个都非法或者一个非法，另一个为空，则返回StmtError，否则将出现问题的一个设为空语句';'，继续分析

另外一个值得注意的地方是对悬空else的处理。在分析'then'语句时会给ParseStatement传进一个InnerStatementTrailingElseLoc的对象引用，如果'then'语句中也含if语句并且有else分支，那么该应用会被置值（成为合法的），如果当前的if语句没有else分支且InnerStatementTrailingElseLoc为合法，那么就会产生一个悬空else的warning。写了一个简单的程序试验了一下，发现这种情况下如果外层的if语句没有显式的加上括号，则clang的确会报相关的警告。


（2）、阅读ParseWhileStatement函数

clang处理scope的方法是，在进入每个作用域时，产生对应的ScopeFlag并以此来新建一个ParseScope对象，在这个对象的构造函数中会调用Parser的EnterScope函数，Parser根据flag产生新的Scope，并注册给负责语义动作的Action；在退出一个作用域时，会调用ParseScope的exit函数，修改Parser中的scope为当前scope的上层作用域，并使用cache机制释放scope。

WhileScope与InnerScope的区别是，WhileScope是整个while语句的作用域，包括条件判断语句和循环体，而InnerScope只是循环体的作用域。WhileScope是InnerScope的外层作用域。

scope在构造和释放时采用了cache机制。即预先分配了一个Scope对象指针数组，在需要释放某个Scope对象时，先判断cache数组中还有没有空位，如果数组已满则进行delete，如果还有空位，则先不进行delete，而将该Scope对象的指针存进cache数组；在需要产生一个Scope对象时，如果cache数组中有空闲的Scope对象的指针，则不进行新的内存分配，而直接将一个空闲的Scope对象初始化为所需的Scope对象。这样可以减少分配和释放内存的次数，从而提高性能。


### 2、阅读分析二元运算表达式的函数

首先ParseExpression调用ParseAssignmentExpression读进并分析一个LHS，然后以LHS和一个最低的运算符优先级（逗号优先级）为参数调用ParseRHSOfBinaryExpression函数来递归的分析二元运算表达式。

ParseRHSOfBinaryExpression读进下一个运算符，首先判断该运算符优先级是否比传入的值高，如果否，直接返回LHS；如果是，则继续读进RHS，i并且读进下一个运算符。如果下一个运算符优先级比当前运算符高，则将RHS更新为递归调用ParseRHSOfBinaryExpression的结果，这里递归调用时传进的第二个参数与当前运算符的结合性有关，如果为左结合，则传进当前优先级加一（因为像a+b+c这样的表达式应该按((a+b)+c)运算），如果为右结合则不用加一（因为a=b=c应该按照(a=(b=c))这样的顺序运算)。之后将LHS与RHS结合为新的LHS，重新回到判断当前运算符（这里的ThisPrec已被更新过）与传入值大小处，以此循环。


### 3、阅读tools/clang/lib/staticAnalyser/README.txt，说明其工作原理

clang的的静态分析器分为两层：静态分析引擎和它之上的接口。静态分析器是通过模拟程序执行的各种路径来工作的，程序执行过程中的状态被封装为ProgramState对象，执行到的位置被封装为ProgramPoint对象，这两者结合成为一个ExplodedGraph的节点。

分析器从ExplodedGraph的根节点开始遍历，分析每一个独立的表达式来模拟程序执行，分析的过程中程序所处的状态会发生改变，并由此产生一个新的ExplodedGraph节点。对于多个执行路径（如条件判断语句），会产生对应的分支，且会对各个分支中的条件变量有约束（这种约束保存在ProgramState对象中），如果对变量的约束不满足某个分支的条件，则不会产生这个分支。通过复用相同的节点来避免ExplodedGraph指数式地增长。

每个独立的checker可以对ProgramState进行操作，而analyzer可以通过visitor接口与checker进行交互。每次analyzer探索了一个新的语句，就会通知每个注册了的checker，给它一个机会报错或改变程序的状态。


### 4、解释debug.DumpCalls的输出

DumpCalls的输出表明了函数中的调用关系。首先是fib(5)，表明在main函数中调用了fib(5)，然后下一层是fib(5)中调用的fib(n-1)和fib(n-2),然后下一层又是这两个函数递归调用的fib(n-1)和fib(n-2)，直到传入的参数为1和2时，fib函数返回1,调用它的函数也依次返回。








