## 阅读Clang语法分析文件
---------------------

### 1、阅读tools/clang/lib/Parse/ParseStmt.cpp 

（1）、阅读ParseIfStatement函数。

ParseIfStatement函数的工作流程：首先读进'if'和一个左括号，然后创建新的作用域IfScope，接着调用ParseParenExprOrCondition读进条件判断表达式。然后为'then'语句块创建一个局部作用域InnerScope（接下来的'else'语句块作用域也叫这个名字，但不是同一个作用域），调用ParseStatement读进并分析'then'语句块。接下来判断下一个token是否为'else'，如果是，则用与解析'then'语句块相同的方法解析'else'语句块（同样要创建一个名为InnerScope的局部作用域）。

3个错误处理手段: 

* 处理开头if后面没有左括号的错误，报缺少左括号的error，并跳过直到下一个分号的一系列token以进行错误恢复，返回StmtError()
* 处理if语句之后（没有else）直接是代码结束，会中断分析，并返回StmtError()
* 处理'then'语句块和'else'语句块出错的问题，如果两个都非法或者一个非法，另一个为空，则返回StmtError，否则将出现问题的一个设为空语句';'，继续分析

另外一个值得注意的地方是对悬空else的处理。在分析'then'语句时会给ParseStatement传进一个InnerStatementTrailingElseLoc的对象引用，如果'then'语句中也含if语句并且有else分支，那么该应用会被置值（成为合法的），如果当前的if语句没有else分支且InnerStatementTrailingElseLoc为合法，那么就会产生一个悬空else的warning。写了一个简单的程序试验了一下，发现这种情况下如果外层的if语句没有显式的加上括号，则clang的确会报相关的警告。


（2）、阅读ParseWhileStatement函数

clang处理scope的方法是，在进入每个作用域时，产生对应的ScopeFlag并以此来新建一个ParseScope对象，在这个对象的构造函数中会调用Parser的EnterScope函数，Parser根据flag产生新的Scope，并注册给负责语义动作的Action；在退出一个作用域时，会调用ParseScope的exit函数，修改Parser中的scope为当前scope的上层作用域，并使用cache机制释放scope。

WhileScope与InnerScope的区别是，WhileScope是整个while语句的作用域，包括条件判断语句和循环体，而InnerScope只是循环体的作用域。WhileScope是InnerScope的外层作用域。

scope在构造和释放时采用了cache机制。即预先分配了一个Scope对象指针数组，在需要释放某个Scope对象时，先判断cache数组中还有没有空位，如果数组已满则进行delete，如果还有空位，则先不进行delete，而将该Scope对象的指针存进cache数组；在需要产生一个Scope对象时，如果cache数组中有空闲的Scope对象的指针，则不进行新的内存分配，而直接将一个空闲的Scope对象初始化为所需的Scope对象。这样可以减少分配和释放内存的次数，从而提高性能。


### 2、阅读分析二元运算表达式的函数

首先ParseExpression调用ParseAssignmentExpression读进并分析一个LHS，然后以LHS和一个最低的运算符优先级（逗号优先级）为参数调用ParseRHSOfBinaryExpression函数来递归的分析二元运算表达式。

ParseRHSOfBinaryExpression读进下一个运算符，首先判断该运算符优先级是否比传入的值高，如果否，直接返回LHS；如果是，则继续读进RHS，i并且读进下一个运算符。如果下一个运算符优先级比当前运算符高，则将RHS更新为递归调用ParseRHSOfBinaryExpression的结果，这里递归调用时传进的第二个参数与当前运算符的结合性有关，如果为左结合，则传进当前优先级加一（因为像a+b+c这样的表达式应该按((a+b)+c)运算），如果为右结合则不用加一（因为a=b=c应该按照(a=(b=c))这样的顺序运算)。之后将LHS与RHS结合为新的LHS，重新回到判断当前运算符（这里的ThisPrec已被更新过）与传入值大小处，以此循环。


### 3、阅读tools/clang/lib/staticAnalyser/README.txt，说明其工作原理

clang的的静态分析器分为两层：静态分析引擎和它之上的接口。静态分析器是通过模拟程序执行的各种路径来工作的，程序执行过程中的状态被封装为ProgramState对象，执行到的位置被封装为ProgramPoint对象，这两者结合成为一个ExplodedGraph的节点。

分析器从ExplodedGraph的根节点开始遍历，分析每一个独立的表达式来模拟程序执行，分析的过程中程序所处的状态会发生改变，并由此产生一个新的ExplodedGraph节点。对于多个执行路径（如条件判断语句），会产生对应的分支，且会对各个分支中的条件变量有约束（这种约束保存在ProgramState对象中），如果对变量的约束不满足某个分支的条件，则不会产生这个分支。通过复用相同的节点来避免ExplodedGraph指数式地增长。

每个独立的checker可以对ProgramState进行操作，而analyzer可以通过visitor接口与checker进行交互。每次analyzer探索了一个新的语句，就会通知每个注册了的checker，给它一个机会报错或改变程序的状态。


### 4、解释debug.DumpCalls的输出

DumpCalls的输出表明了函数中的调用关系。首先是fib(5)，表明在main函数中调用了fib(5)，然后下一层是fib(5)中调用的fib(n-1)和fib(n-2),然后下一层又是这两个函数递归调用的fib(n-1)和fib(n-2)，直到传入的参数为1和2时，fib函数返回1,调用它的函数也依次返回。


### 5、UnreachableCodeChecker的工作原理及一个它检查不出来的例子

UnreachableCodeChecker实现了回调函数checkEndAnalysis，该函数在分析完成后会被执行，从而根据得到的完整ExplodeGraph来判断那些代码是不会被执行的。它的工作流程主要分两步，首先遍历ExplodedGraph，对节点中的每个ProgramPoint，给它的CFGBlock作上标记（即把它的Block加入一个set），这样一趟遍历下来所有能执行到的语句块都会被标记；然后再遍历CFGGraph，找出没有标记的Block，这样就找到了不会被执行到的语句块（这里还会有一系列检查避免误判，如接下来说的default标号的情况），然后再据此通过BugReporter把信息反馈出来。

一个它检查不出来的不可达代码（写在test/unreachable.c中）：
一个switch语句中的default标号后的语句，即使永远不会被执行，也不会使UnreachableChecker报错。这是因为clang认为在switch中始终加一个default是良好的编程习惯，所以会跳过default标号后的不可达代码。故default后面的不可达代码不会使UnreachableChecker检测出来。


### 6、结合clang-check和Checkers.inc，说明clang是如何加载各个Checker并在代码上进行检验的

从Checkers.inc到clang-check要经过很多层的代码，下面从Checker.inc开始“自底向上”地逐步说明Checker加载的过程。

首先在Checkers.inc中有各个built-in的Checker进行register的宏，这里的CHECKER宏有两种宏展开，既在ClangSAChecker.h中展开成函数的声明，又在ClangCheckers.cpp中展开成registry.addChecker函数的调用，其目的是为了方便地注册各个built-in的Checker，所有内置Checker函数的注册被这样封装在函数registerBuiltinCheckers中。在ClangCheckerRegistry对象的构造函数中会首先调用这个registerBuiltinCheckers函数来完成对内置Checker的注册。

接下来的一层是CheckerManager对象，CheckerManager的构造是通过createCheckManager函数完成的，该函数先创建一个ClangCheckerRegistry的临时变量，并调用他的initializeManager方法来将checker注册到manager上。

再接下来是AnalysisConsumer对象，这个对象继承自ASTConsumer对象（实际上是一个接口），通过它才能读取AST，并且需要通过他来形成一个FrontendAction。AnalysisConsumer中包含一个CheckerManager，因此也包含了注册好的Checker。

再接下来到了AnalysisAction对象，它继承自ASTFrontendAction对象。顾名思义，它是一个需要使用到AST的前端语义动作，它返回一个上一段提到的AnalysisConsumer对象，并通过返回的AnalysisConsumer来起作用。这里，我们已经很接近“最上层”的clang-check了！

接下来就是ClangCheck.cpp中的内容了，在main函数中，分析用户从命令行传进的options后，如果是analyze选项，则通过AnalysisAction对象来初始化一个FrontendActionFactory（如果是别的选项则以另外的途径初始化这个工厂）。然后，通过ClangTool对象（用于独立于parser地执行FrontendAction，注意这里已经将用户的选项传给了tool，所以它可以加载正确的checker），以FrontendActionFactory产生的action为参数调用run函数，从而加载各个用到的Checker来执行对应的动作。

总结一下，Checker.inc通过宏定义来方便注册各个checker到registry中，这些checkers被封装进CheckerManager，又为了使用相应的接口而封装成前端动作AnalysisAction，这个动作被传给clang-check使用；而clang-check作为一个可以从命令行调用的工具，分析完用户的选项后通过ClangTool对象执行对应的Action，从而加载和调用checker。


### 7、tools/clang/tools/driver/中的文件会生成clang，main函数在driver.cpp中，请大致说明它如何调用负责编译的函数？如何处理cc1参数？

（1）、如何调用编译的函数

首先对用户的命令进行解析，判断第一个参数是不是以cc1开头，如果是，直接执行cc1工具，如果不是则继续进行编译。之后实例化一个Driver对象用于执行编译。然后解析程序名，根据用户调用所使用的的程序名确定使用什么样的前端（比如C还是C++），这是通过一个从程序名字后缀映射到编译mode选项的表DriverSuffixes来完成的。然后确定它的target，即目标平台，这是通过分析程序名字的前缀来完成的（如x86_64-linux-clang，其前缀x86_64-linux指明了目标平台），同样是转化为编译选项，插入到argv中。分析了这两部分内容之后，以driver和解析过后的argv来实例化一个Compilation对象，Compilation是一系列具体的编译任务的集合。之后driver执行编译，并返回一个结果，Diag将编译结果反馈给用户。

（2）、如何处理cc1参数

clang对于cc1参数是单独进行处理的，相关代码在cc1_main.cpp和cc1as_main.cpp中。解析用户的命令时，会首先判断第一个选项是否是-cc1,如果是，则不继续原来的编译，转而根据cc1后面是否跟as来判断执行cc1_main还是cc1as_main，这里以cc1_main为例来说明。实例化一个CompilerInstance，然后进行llvm的一系列初始化。之后调用CompilerInstance的CreateFromArgs对参数Argv进行解析，如果参数有误，则将错误信息反馈给用户。然后刷新错误信息缓存，以CompilerInstance为参数调用ExecuteCompilerInvocation来执行用户选项所指定的动作。


