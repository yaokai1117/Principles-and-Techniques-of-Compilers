## P5
--------------------

## 问题回答

### 5.1.2 查看config/parser.y，以input->empty|input line为例，说明AST的结构和构建过程。解释$$, $1, $2, @$等变量的含义。

答：AST的结构分为两种，一种是像input这样，包含一个列表，这种AST节点的构建一般分为创建（在input->empty的语义动作中进行）和append将子节点的指针加入列表中（在input->input line的语义动作中进行）；另一种像BinaryExpNode这样，结构比较简单，包含它本身的一些信息（如op，name）和语法树子节点的指针（如lhs，rhs），这种节点直接在归约时产生（如BinaryExpNode在Exp->Exp + Exp归约的语义动作中产生）。

$$为产生式左边符号的语义值，其类型在%type中定义，$1,$2...分别为产生式右边第1,2,..个符号的语义值。@$为产生式左边符号的位置结构体的值，@1,@2...等分别为产生式右边第1，2...个符号的位置结构体的值。


### 5.2.1 思考AST在语法分析中的创建和信息填充时机。

答：创建时机一般都在对应产生式归约的语义动作中，如BinaryExpNode的创建是在产生式Exp->Exp + Exp的语义动作中，InputNode的创建在产生式Input->empty的语义动作中。
信息填充时机分两种。一种是列表型的AST，在每个子节点被归约进来时执行append将子节点的指针加入列表中，如input->input line的产生式中，将line的AST节点指针append进input的AST节点中；另一种是BinaryExpNode这样的简单AST节点，在归约的语义动作中创建，并同时填充信息。

## 设计文档

### 1.生成AST
在每个产生式的语义动作中创建AST节点，对于文法中某个模式重复一次或多次的情况，写成左递归的形式，用类似助教所给示例的办法创建AST并填充信息。在完成这个部分时比较花时间的是对AST节点类的定义，需要处理好各个Node类之间的继承关系。

### 2.处理出错后的AST空间释放
一开始的想法是设一个errorFlag，仅在errorFlag设为false时才创建节点，同时给每个AST类写好析构函数，最后“delete root”就可以自动释放整棵树。出现错误时，将errorFlag置true，不再创建节点，$$设为NULL，且删除该产生式中已经生成的节点。以后也不再生成节点，而是检测产生式右边每个AST节点的语义值$1,$2等，若不为NULL，则进行释放。这样可以处理无错误和错误能够被恢复的程序，但在遇到恢复不了的错误（即syntax error并直接终止parse的情况），就会不可避免的有内存泄露。

之后采取了每生成一个AST对象就将它的指针记录在一个全局变量中，发生错误时立即删除，且将errorFlag置为true，以后不再生成节点。这样的方法反而较之前的要简单一些，且行之有效。使用检测内存泄露的工具valgrind对test/里每个样例进行检查后，结果都显示no leaks。

### 3.处理注释
行注释比较简单，直接在词法分析部分写正则表达式进行捕获即可。
块注释略复杂一些，因为要处理column number变化的问题，这里我采取的方法仍是在词法分析部分写正则表达式捕获，同时对捕获到的yytext进行分析，以得出正确的位置信息，再更新yycolumn。



